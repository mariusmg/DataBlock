/*
  
       file: GraphBuilder.cs
description: creates the graph of sql queries from a root table and his relations.
             This is used by the SqlBuidler's GenerateMultipleInsert method. 

  (c) 2004 - 2008 Marius Gheorghe. All rights reserved.

  
*/

using System;
using System.Collections.Generic;

namespace voidsoft.DataBlock
{
	/// <summary>
	///     Internal class which is used to create high level hierachical representations
	///     of related TableMetadata objects
	/// </summary>
	internal class GraphBuilder
	{
		/// <summary>
		///     Gets the graph list of a hierachical TableMetadata objects.
		///     Also it adds the INSERT (FK) contraints into the hierachy.
		/// </summary>
		/// <param name="entity">Main TableMetadata which is the root of the graph</param>
		/// <param name="list">List which contains the resulted data</param>
		/// <param name="listTablesNames">List which contains the name of the tables</param>
		public void BuildGraphList(TableMetadata entity, ref List<object> list, ref List<string> listTablesNames)
		{
			TableMetadata[] attachedData = entity.AttachedData;

			//get the attached data based on relation type.
			List<TableMetadata> dataParent = GetAttachedDataBasedOnRelationType(entity, true);

			//the primary key field of the main table
			DatabaseField primaryKey = entity.GetPrimaryKeyField();

			bool insertConstraint = false;

			string foreignKeyName;

			if (dataParent.Count > 0)
			{
				//check to see if the value of the PK is autoassigned or not
				if (!primaryKey.isValueAutogenerated)
				{
					object pkValue = primaryKey.fieldValue;

					//first check the value of the primary key is set
					if (pkValue == null)
					{
						throw new ArgumentException("The PK value is null for table " + entity + " when the PK is not autogenerated");
					}

					//set the value in the child tables
					foreach (TableMetadata currentTable in dataParent)
					{
						foreignKeyName = MetadataManager.GetForeignKeyName(entity, currentTable);
						currentTable.SetFieldValue(foreignKeyName, pkValue);
					}
				}
				else
				{
					insertConstraint = true;

					foreach (TableMetadata currentTable in dataParent)
					{
						foreignKeyName = MetadataManager.GetForeignKeyName(entity, currentTable);
						currentTable.SetFieldValue(foreignKeyName, "???");
					}
				}

				//check if we insert constraints to this table.
				if (insertConstraint)
				{
					if (!listTablesNames.Contains(entity.TableName))
					{
						list.Add(ExecutionEngine.FOREIGN_KEY_CONSTRAINT + "//" + dataParent.Count.ToString() + "//" + entity.TableName + "//" + primaryKey.fieldName);
						list.Add(entity);

						//add it to the list of tables with constraints.
						listTablesNames.Add(entity.TableName);
					}
				}

				//now add the child tables
				for (int i = 0; i < dataParent.Count; i++)
				{
					List<TableMetadata> temp = GetAttachedDataBasedOnRelationType(dataParent[i], true);

					if (temp.Count == 0)
					{
						//add all the child tables.
						list.Add(dataParent[i]);
					}
				}

				//loop thru all the childs of the main table and add to the graph.
				foreach (TableMetadata var in attachedData)
				{
					BuildGraphList(var, ref list, ref listTablesNames);
				}
			}
		}

		/// <summary>
		///     Returns the attached table metadata from the main table based on the
		///     relation type.
		/// </summary>
		/// <param name="entity">Parent TableMetadata</param>
		/// <param name="parentRelations">Boolean flag which signals that only </param>
		/// <returns>List of the attached data</returns>
		internal List<TableMetadata> GetAttachedDataBasedOnRelationType(TableMetadata entity, bool parentRelations)
		{
			List<TableMetadata> dataList = new List<TableMetadata>();

			//return only the tables in which the mappedObject is parent.
			if (parentRelations)
			{
				List<ParentTableRelation> list = MetadataManager.GetParentRelations(entity);

				TableMetadata[] data = entity.AttachedData;

				bool foundIt = false;

				foreach (TableMetadata table in data)
				{
					foundIt = false;

					foreach (ParentTableRelation relation in list)
					{
						if (relation.RelatedTableName == table.TableName)
						{
							foundIt = true;
							break;
						}
					}

					if (foundIt)
					{
						dataList.Add(table);
					}
				}
			}
			else
			{
				//return only the tables in which the 

				List<ChildTableRelation> list = MetadataManager.GetChildRelations(entity);

				TableMetadata[] data = entity.AttachedData;

				bool foundIt = false;

				foreach (TableMetadata table in data)
				{
					foundIt = false;

					foreach (ChildTableRelation relation in list)
					{
						if (relation.RelatedTableName == table.TableName)
						{
							foundIt = true;
							break;
						}
					}

					if (foundIt)
					{
						dataList.Add(table);
					}
				}
			}

			return dataList;
		}
	}
}